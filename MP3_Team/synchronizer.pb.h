// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: synchronizer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_synchronizer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_synchronizer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_synchronizer_2eproto;
namespace csce438 {
class ClientReply;
struct ClientReplyDefaultTypeInternal;
extern ClientReplyDefaultTypeInternal _ClientReply_default_instance_;
class ClientRequest;
struct ClientRequestDefaultTypeInternal;
extern ClientRequestDefaultTypeInternal _ClientRequest_default_instance_;
class FollowReply;
struct FollowReplyDefaultTypeInternal;
extern FollowReplyDefaultTypeInternal _FollowReply_default_instance_;
class FollowRequest;
struct FollowRequestDefaultTypeInternal;
extern FollowRequestDefaultTypeInternal _FollowRequest_default_instance_;
class SyncMessage;
struct SyncMessageDefaultTypeInternal;
extern SyncMessageDefaultTypeInternal _SyncMessage_default_instance_;
}  // namespace csce438
PROTOBUF_NAMESPACE_OPEN
template<> ::csce438::ClientReply* Arena::CreateMaybeMessage<::csce438::ClientReply>(Arena*);
template<> ::csce438::ClientRequest* Arena::CreateMaybeMessage<::csce438::ClientRequest>(Arena*);
template<> ::csce438::FollowReply* Arena::CreateMaybeMessage<::csce438::FollowReply>(Arena*);
template<> ::csce438::FollowRequest* Arena::CreateMaybeMessage<::csce438::FollowRequest>(Arena*);
template<> ::csce438::SyncMessage* Arena::CreateMaybeMessage<::csce438::SyncMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace csce438 {

// ===================================================================

class FollowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.FollowRequest) */ {
 public:
  inline FollowRequest() : FollowRequest(nullptr) {}
  ~FollowRequest() override;
  explicit constexpr FollowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowRequest(const FollowRequest& from);
  FollowRequest(FollowRequest&& from) noexcept
    : FollowRequest() {
    *this = ::std::move(from);
  }

  inline FollowRequest& operator=(const FollowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowRequest& operator=(FollowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowRequest* internal_default_instance() {
    return reinterpret_cast<const FollowRequest*>(
               &_FollowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FollowRequest& a, FollowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowRequest* New() const final {
    return new FollowRequest();
  }

  FollowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FollowRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.FollowRequest";
  }
  protected:
  explicit FollowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kFollowerFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string follower = 2;
  void clear_follower();
  const std::string& follower() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_follower(ArgT0&& arg0, ArgT... args);
  std::string* mutable_follower();
  PROTOBUF_MUST_USE_RESULT std::string* release_follower();
  void set_allocated_follower(std::string* follower);
  private:
  const std::string& _internal_follower() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_follower(const std::string& value);
  std::string* _internal_mutable_follower();
  public:

  // @@protoc_insertion_point(class_scope:csce438.FollowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr follower_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_synchronizer_2eproto;
};
// -------------------------------------------------------------------

class FollowReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.FollowReply) */ {
 public:
  inline FollowReply() : FollowReply(nullptr) {}
  ~FollowReply() override;
  explicit constexpr FollowReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowReply(const FollowReply& from);
  FollowReply(FollowReply&& from) noexcept
    : FollowReply() {
    *this = ::std::move(from);
  }

  inline FollowReply& operator=(const FollowReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowReply& operator=(FollowReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowReply* internal_default_instance() {
    return reinterpret_cast<const FollowReply*>(
               &_FollowReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FollowReply& a, FollowReply& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowReply* New() const final {
    return new FollowReply();
  }

  FollowReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FollowReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.FollowReply";
  }
  protected:
  explicit FollowReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:csce438.FollowReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_synchronizer_2eproto;
};
// -------------------------------------------------------------------

class ClientRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ClientRequest) */ {
 public:
  inline ClientRequest() : ClientRequest(nullptr) {}
  ~ClientRequest() override;
  explicit constexpr ClientRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientRequest(const ClientRequest& from);
  ClientRequest(ClientRequest&& from) noexcept
    : ClientRequest() {
    *this = ::std::move(from);
  }

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRequest& operator=(ClientRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRequest* internal_default_instance() {
    return reinterpret_cast<const ClientRequest*>(
               &_ClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientRequest& a, ClientRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientRequest* New() const final {
    return new ClientRequest();
  }

  ClientRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.ClientRequest";
  }
  protected:
  explicit ClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerRequesterIdFieldNumber = 1,
    kServerReplierIdFieldNumber = 2,
  };
  // string server_requester_id = 1;
  void clear_server_requester_id();
  const std::string& server_requester_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_requester_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_requester_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_requester_id();
  void set_allocated_server_requester_id(std::string* server_requester_id);
  private:
  const std::string& _internal_server_requester_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_requester_id(const std::string& value);
  std::string* _internal_mutable_server_requester_id();
  public:

  // string server_replier_id = 2;
  void clear_server_replier_id();
  const std::string& server_replier_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_replier_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_replier_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_replier_id();
  void set_allocated_server_replier_id(std::string* server_replier_id);
  private:
  const std::string& _internal_server_replier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_replier_id(const std::string& value);
  std::string* _internal_mutable_server_replier_id();
  public:

  // @@protoc_insertion_point(class_scope:csce438.ClientRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_requester_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_replier_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_synchronizer_2eproto;
};
// -------------------------------------------------------------------

class ClientReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ClientReply) */ {
 public:
  inline ClientReply() : ClientReply(nullptr) {}
  ~ClientReply() override;
  explicit constexpr ClientReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientReply(const ClientReply& from);
  ClientReply(ClientReply&& from) noexcept
    : ClientReply() {
    *this = ::std::move(from);
  }

  inline ClientReply& operator=(const ClientReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientReply& operator=(ClientReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientReply* internal_default_instance() {
    return reinterpret_cast<const ClientReply*>(
               &_ClientReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientReply& a, ClientReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientReply* New() const final {
    return new ClientReply();
  }

  ClientReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.ClientReply";
  }
  protected:
  explicit ClientReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientsFieldNumber = 1,
  };
  // repeated string clients = 1;
  int clients_size() const;
  private:
  int _internal_clients_size() const;
  public:
  void clear_clients();
  const std::string& clients(int index) const;
  std::string* mutable_clients(int index);
  void set_clients(int index, const std::string& value);
  void set_clients(int index, std::string&& value);
  void set_clients(int index, const char* value);
  void set_clients(int index, const char* value, size_t size);
  std::string* add_clients();
  void add_clients(const std::string& value);
  void add_clients(std::string&& value);
  void add_clients(const char* value);
  void add_clients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clients();
  private:
  const std::string& _internal_clients(int index) const;
  std::string* _internal_add_clients();
  public:

  // @@protoc_insertion_point(class_scope:csce438.ClientReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clients_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_synchronizer_2eproto;
};
// -------------------------------------------------------------------

class SyncMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.SyncMessage) */ {
 public:
  inline SyncMessage() : SyncMessage(nullptr) {}
  ~SyncMessage() override;
  explicit constexpr SyncMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncMessage(const SyncMessage& from);
  SyncMessage(SyncMessage&& from) noexcept
    : SyncMessage() {
    *this = ::std::move(from);
  }

  inline SyncMessage& operator=(const SyncMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncMessage& operator=(SyncMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncMessage* internal_default_instance() {
    return reinterpret_cast<const SyncMessage*>(
               &_SyncMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SyncMessage& a, SyncMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SyncMessage* New() const final {
    return new SyncMessage();
  }

  SyncMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SyncMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SyncMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.SyncMessage";
  }
  protected:
  explicit SyncMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFollowersFieldNumber = 4,
    kUsernameFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // repeated string followers = 4;
  int followers_size() const;
  private:
  int _internal_followers_size() const;
  public:
  void clear_followers();
  const std::string& followers(int index) const;
  std::string* mutable_followers(int index);
  void set_followers(int index, const std::string& value);
  void set_followers(int index, std::string&& value);
  void set_followers(int index, const char* value);
  void set_followers(int index, const char* value, size_t size);
  std::string* add_followers();
  void add_followers(const std::string& value);
  void add_followers(std::string&& value);
  void add_followers(const char* value);
  void add_followers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& followers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_followers();
  private:
  const std::string& _internal_followers(int index) const;
  std::string* _internal_add_followers();
  public:

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:csce438.SyncMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> followers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_synchronizer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FollowRequest

// string username = 1;
inline void FollowRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& FollowRequest::username() const {
  // @@protoc_insertion_point(field_get:csce438.FollowRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowRequest.username)
}
inline std::string* FollowRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:csce438.FollowRequest.username)
  return _s;
}
inline const std::string& FollowRequest::_internal_username() const {
  return username_.Get();
}
inline void FollowRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowRequest::release_username() {
  // @@protoc_insertion_point(field_release:csce438.FollowRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowRequest.username)
}

// string follower = 2;
inline void FollowRequest::clear_follower() {
  follower_.ClearToEmpty();
}
inline const std::string& FollowRequest::follower() const {
  // @@protoc_insertion_point(field_get:csce438.FollowRequest.follower)
  return _internal_follower();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowRequest::set_follower(ArgT0&& arg0, ArgT... args) {
 
 follower_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowRequest.follower)
}
inline std::string* FollowRequest::mutable_follower() {
  std::string* _s = _internal_mutable_follower();
  // @@protoc_insertion_point(field_mutable:csce438.FollowRequest.follower)
  return _s;
}
inline const std::string& FollowRequest::_internal_follower() const {
  return follower_.Get();
}
inline void FollowRequest::_internal_set_follower(const std::string& value) {
  
  follower_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowRequest::_internal_mutable_follower() {
  
  return follower_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowRequest::release_follower() {
  // @@protoc_insertion_point(field_release:csce438.FollowRequest.follower)
  return follower_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowRequest::set_allocated_follower(std::string* follower) {
  if (follower != nullptr) {
    
  } else {
    
  }
  follower_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), follower,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowRequest.follower)
}

// -------------------------------------------------------------------

// FollowReply

// string msg = 1;
inline void FollowReply::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& FollowReply::msg() const {
  // @@protoc_insertion_point(field_get:csce438.FollowReply.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowReply::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowReply.msg)
}
inline std::string* FollowReply::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:csce438.FollowReply.msg)
  return _s;
}
inline const std::string& FollowReply::_internal_msg() const {
  return msg_.Get();
}
inline void FollowReply::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowReply::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowReply::release_msg() {
  // @@protoc_insertion_point(field_release:csce438.FollowReply.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowReply.msg)
}

// -------------------------------------------------------------------

// ClientRequest

// string server_requester_id = 1;
inline void ClientRequest::clear_server_requester_id() {
  server_requester_id_.ClearToEmpty();
}
inline const std::string& ClientRequest::server_requester_id() const {
  // @@protoc_insertion_point(field_get:csce438.ClientRequest.server_requester_id)
  return _internal_server_requester_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientRequest::set_server_requester_id(ArgT0&& arg0, ArgT... args) {
 
 server_requester_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.ClientRequest.server_requester_id)
}
inline std::string* ClientRequest::mutable_server_requester_id() {
  std::string* _s = _internal_mutable_server_requester_id();
  // @@protoc_insertion_point(field_mutable:csce438.ClientRequest.server_requester_id)
  return _s;
}
inline const std::string& ClientRequest::_internal_server_requester_id() const {
  return server_requester_id_.Get();
}
inline void ClientRequest::_internal_set_server_requester_id(const std::string& value) {
  
  server_requester_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientRequest::_internal_mutable_server_requester_id() {
  
  return server_requester_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientRequest::release_server_requester_id() {
  // @@protoc_insertion_point(field_release:csce438.ClientRequest.server_requester_id)
  return server_requester_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientRequest::set_allocated_server_requester_id(std::string* server_requester_id) {
  if (server_requester_id != nullptr) {
    
  } else {
    
  }
  server_requester_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_requester_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.ClientRequest.server_requester_id)
}

// string server_replier_id = 2;
inline void ClientRequest::clear_server_replier_id() {
  server_replier_id_.ClearToEmpty();
}
inline const std::string& ClientRequest::server_replier_id() const {
  // @@protoc_insertion_point(field_get:csce438.ClientRequest.server_replier_id)
  return _internal_server_replier_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientRequest::set_server_replier_id(ArgT0&& arg0, ArgT... args) {
 
 server_replier_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.ClientRequest.server_replier_id)
}
inline std::string* ClientRequest::mutable_server_replier_id() {
  std::string* _s = _internal_mutable_server_replier_id();
  // @@protoc_insertion_point(field_mutable:csce438.ClientRequest.server_replier_id)
  return _s;
}
inline const std::string& ClientRequest::_internal_server_replier_id() const {
  return server_replier_id_.Get();
}
inline void ClientRequest::_internal_set_server_replier_id(const std::string& value) {
  
  server_replier_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientRequest::_internal_mutable_server_replier_id() {
  
  return server_replier_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientRequest::release_server_replier_id() {
  // @@protoc_insertion_point(field_release:csce438.ClientRequest.server_replier_id)
  return server_replier_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientRequest::set_allocated_server_replier_id(std::string* server_replier_id) {
  if (server_replier_id != nullptr) {
    
  } else {
    
  }
  server_replier_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_replier_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.ClientRequest.server_replier_id)
}

// -------------------------------------------------------------------

// ClientReply

// repeated string clients = 1;
inline int ClientReply::_internal_clients_size() const {
  return clients_.size();
}
inline int ClientReply::clients_size() const {
  return _internal_clients_size();
}
inline void ClientReply::clear_clients() {
  clients_.Clear();
}
inline std::string* ClientReply::add_clients() {
  std::string* _s = _internal_add_clients();
  // @@protoc_insertion_point(field_add_mutable:csce438.ClientReply.clients)
  return _s;
}
inline const std::string& ClientReply::_internal_clients(int index) const {
  return clients_.Get(index);
}
inline const std::string& ClientReply::clients(int index) const {
  // @@protoc_insertion_point(field_get:csce438.ClientReply.clients)
  return _internal_clients(index);
}
inline std::string* ClientReply::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.ClientReply.clients)
  return clients_.Mutable(index);
}
inline void ClientReply::set_clients(int index, const std::string& value) {
  clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.ClientReply.clients)
}
inline void ClientReply::set_clients(int index, std::string&& value) {
  clients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.ClientReply.clients)
}
inline void ClientReply::set_clients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.ClientReply.clients)
}
inline void ClientReply::set_clients(int index, const char* value, size_t size) {
  clients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.ClientReply.clients)
}
inline std::string* ClientReply::_internal_add_clients() {
  return clients_.Add();
}
inline void ClientReply::add_clients(const std::string& value) {
  clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.ClientReply.clients)
}
inline void ClientReply::add_clients(std::string&& value) {
  clients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.ClientReply.clients)
}
inline void ClientReply::add_clients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.ClientReply.clients)
}
inline void ClientReply::add_clients(const char* value, size_t size) {
  clients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.ClientReply.clients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClientReply::clients() const {
  // @@protoc_insertion_point(field_list:csce438.ClientReply.clients)
  return clients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClientReply::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:csce438.ClientReply.clients)
  return &clients_;
}

// -------------------------------------------------------------------

// SyncMessage

// string username = 1;
inline void SyncMessage::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& SyncMessage::username() const {
  // @@protoc_insertion_point(field_get:csce438.SyncMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.SyncMessage.username)
}
inline std::string* SyncMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:csce438.SyncMessage.username)
  return _s;
}
inline const std::string& SyncMessage::_internal_username() const {
  return username_.Get();
}
inline void SyncMessage::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SyncMessage::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SyncMessage::release_username() {
  // @@protoc_insertion_point(field_release:csce438.SyncMessage.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SyncMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.SyncMessage.username)
}

// string msg = 2;
inline void SyncMessage::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& SyncMessage::msg() const {
  // @@protoc_insertion_point(field_get:csce438.SyncMessage.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncMessage::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.SyncMessage.msg)
}
inline std::string* SyncMessage::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:csce438.SyncMessage.msg)
  return _s;
}
inline const std::string& SyncMessage::_internal_msg() const {
  return msg_.Get();
}
inline void SyncMessage::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SyncMessage::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SyncMessage::release_msg() {
  // @@protoc_insertion_point(field_release:csce438.SyncMessage.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SyncMessage::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.SyncMessage.msg)
}

// repeated string followers = 4;
inline int SyncMessage::_internal_followers_size() const {
  return followers_.size();
}
inline int SyncMessage::followers_size() const {
  return _internal_followers_size();
}
inline void SyncMessage::clear_followers() {
  followers_.Clear();
}
inline std::string* SyncMessage::add_followers() {
  std::string* _s = _internal_add_followers();
  // @@protoc_insertion_point(field_add_mutable:csce438.SyncMessage.followers)
  return _s;
}
inline const std::string& SyncMessage::_internal_followers(int index) const {
  return followers_.Get(index);
}
inline const std::string& SyncMessage::followers(int index) const {
  // @@protoc_insertion_point(field_get:csce438.SyncMessage.followers)
  return _internal_followers(index);
}
inline std::string* SyncMessage::mutable_followers(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.SyncMessage.followers)
  return followers_.Mutable(index);
}
inline void SyncMessage::set_followers(int index, const std::string& value) {
  followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.SyncMessage.followers)
}
inline void SyncMessage::set_followers(int index, std::string&& value) {
  followers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.SyncMessage.followers)
}
inline void SyncMessage::set_followers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.SyncMessage.followers)
}
inline void SyncMessage::set_followers(int index, const char* value, size_t size) {
  followers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.SyncMessage.followers)
}
inline std::string* SyncMessage::_internal_add_followers() {
  return followers_.Add();
}
inline void SyncMessage::add_followers(const std::string& value) {
  followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.SyncMessage.followers)
}
inline void SyncMessage::add_followers(std::string&& value) {
  followers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.SyncMessage.followers)
}
inline void SyncMessage::add_followers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.SyncMessage.followers)
}
inline void SyncMessage::add_followers(const char* value, size_t size) {
  followers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.SyncMessage.followers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SyncMessage::followers() const {
  // @@protoc_insertion_point(field_list:csce438.SyncMessage.followers)
  return followers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SyncMessage::mutable_followers() {
  // @@protoc_insertion_point(field_mutable_list:csce438.SyncMessage.followers)
  return &followers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace csce438

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto

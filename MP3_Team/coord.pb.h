// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coord.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_coord_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_coord_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_coord_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_coord_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_coord_2eproto;
namespace csce438 {
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class ClusterInfo;
struct ClusterInfoDefaultTypeInternal;
extern ClusterInfoDefaultTypeInternal _ClusterInfo_default_instance_;
class CoordMessage;
struct CoordMessageDefaultTypeInternal;
extern CoordMessageDefaultTypeInternal _CoordMessage_default_instance_;
class CoordReply;
struct CoordReplyDefaultTypeInternal;
extern CoordReplyDefaultTypeInternal _CoordReply_default_instance_;
class CoordRequest;
struct CoordRequestDefaultTypeInternal;
extern CoordRequestDefaultTypeInternal _CoordRequest_default_instance_;
class FollowerSyncInfo;
struct FollowerSyncInfoDefaultTypeInternal;
extern FollowerSyncInfoDefaultTypeInternal _FollowerSyncInfo_default_instance_;
class FollowerSyncRTInfo;
struct FollowerSyncRTInfoDefaultTypeInternal;
extern FollowerSyncRTInfoDefaultTypeInternal _FollowerSyncRTInfo_default_instance_;
class MasterReply;
struct MasterReplyDefaultTypeInternal;
extern MasterReplyDefaultTypeInternal _MasterReply_default_instance_;
class MasterRequest;
struct MasterRequestDefaultTypeInternal;
extern MasterRequestDefaultTypeInternal _MasterRequest_default_instance_;
class SyncIdInfo;
struct SyncIdInfoDefaultTypeInternal;
extern SyncIdInfoDefaultTypeInternal _SyncIdInfo_default_instance_;
}  // namespace csce438
PROTOBUF_NAMESPACE_OPEN
template<> ::csce438::ClientInfo* Arena::CreateMaybeMessage<::csce438::ClientInfo>(Arena*);
template<> ::csce438::ClusterInfo* Arena::CreateMaybeMessage<::csce438::ClusterInfo>(Arena*);
template<> ::csce438::CoordMessage* Arena::CreateMaybeMessage<::csce438::CoordMessage>(Arena*);
template<> ::csce438::CoordReply* Arena::CreateMaybeMessage<::csce438::CoordReply>(Arena*);
template<> ::csce438::CoordRequest* Arena::CreateMaybeMessage<::csce438::CoordRequest>(Arena*);
template<> ::csce438::FollowerSyncInfo* Arena::CreateMaybeMessage<::csce438::FollowerSyncInfo>(Arena*);
template<> ::csce438::FollowerSyncRTInfo* Arena::CreateMaybeMessage<::csce438::FollowerSyncRTInfo>(Arena*);
template<> ::csce438::MasterReply* Arena::CreateMaybeMessage<::csce438::MasterReply>(Arena*);
template<> ::csce438::MasterRequest* Arena::CreateMaybeMessage<::csce438::MasterRequest>(Arena*);
template<> ::csce438::SyncIdInfo* Arena::CreateMaybeMessage<::csce438::SyncIdInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace csce438 {

// ===================================================================

class CoordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.CoordRequest) */ {
 public:
  inline CoordRequest() : CoordRequest(nullptr) {}
  ~CoordRequest() override;
  explicit constexpr CoordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordRequest(const CoordRequest& from);
  CoordRequest(CoordRequest&& from) noexcept
    : CoordRequest() {
    *this = ::std::move(from);
  }

  inline CoordRequest& operator=(const CoordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordRequest& operator=(CoordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordRequest* internal_default_instance() {
    return reinterpret_cast<const CoordRequest*>(
               &_CoordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CoordRequest& a, CoordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordRequest* New() const final {
    return new CoordRequest();
  }

  CoordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoordRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.CoordRequest";
  }
  protected:
  explicit CoordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:csce438.CoordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class CoordReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.CoordReply) */ {
 public:
  inline CoordReply() : CoordReply(nullptr) {}
  ~CoordReply() override;
  explicit constexpr CoordReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordReply(const CoordReply& from);
  CoordReply(CoordReply&& from) noexcept
    : CoordReply() {
    *this = ::std::move(from);
  }

  inline CoordReply& operator=(const CoordReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordReply& operator=(CoordReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordReply* internal_default_instance() {
    return reinterpret_cast<const CoordReply*>(
               &_CoordReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CoordReply& a, CoordReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordReply* New() const final {
    return new CoordReply();
  }

  CoordReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoordReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.CoordReply";
  }
  protected:
  explicit CoordReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIpAddressFieldNumber = 1,
    kServerPortFieldNumber = 2,
  };
  // string server_ip_address = 1;
  void clear_server_ip_address();
  const std::string& server_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_ip_address();
  void set_allocated_server_ip_address(std::string* server_ip_address);
  private:
  const std::string& _internal_server_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_ip_address(const std::string& value);
  std::string* _internal_mutable_server_ip_address();
  public:

  // string server_port = 2;
  void clear_server_port();
  const std::string& server_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_port();
  void set_allocated_server_port(std::string* server_port);
  private:
  const std::string& _internal_server_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_port(const std::string& value);
  std::string* _internal_mutable_server_port();
  public:

  // @@protoc_insertion_point(class_scope:csce438.CoordReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class CoordMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.CoordMessage) */ {
 public:
  inline CoordMessage() : CoordMessage(nullptr) {}
  ~CoordMessage() override;
  explicit constexpr CoordMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordMessage(const CoordMessage& from);
  CoordMessage(CoordMessage&& from) noexcept
    : CoordMessage() {
    *this = ::std::move(from);
  }

  inline CoordMessage& operator=(const CoordMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordMessage& operator=(CoordMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordMessage* internal_default_instance() {
    return reinterpret_cast<const CoordMessage*>(
               &_CoordMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CoordMessage& a, CoordMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoordMessage* New() const final {
    return new CoordMessage();
  }

  CoordMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoordMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoordMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.CoordMessage";
  }
  protected:
  explicit CoordMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIpFieldNumber = 1,
    kServerPort2FieldNumber = 2,
    kStatusFieldNumber = 3,
    kServerTypeFieldNumber = 4,
  };
  // string server_ip = 1;
  void clear_server_ip();
  const std::string& server_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_ip();
  void set_allocated_server_ip(std::string* server_ip);
  private:
  const std::string& _internal_server_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_ip(const std::string& value);
  std::string* _internal_mutable_server_ip();
  public:

  // string server_port2 = 2;
  void clear_server_port2();
  const std::string& server_port2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_port2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_port2();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_port2();
  void set_allocated_server_port2(std::string* server_port2);
  private:
  const std::string& _internal_server_port2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_port2(const std::string& value);
  std::string* _internal_mutable_server_port2();
  public:

  // string status = 3;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string server_type = 4;
  void clear_server_type();
  const std::string& server_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_type();
  void set_allocated_server_type(std::string* server_type);
  private:
  const std::string& _internal_server_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_type(const std::string& value);
  std::string* _internal_mutable_server_type();
  public:

  // @@protoc_insertion_point(class_scope:csce438.CoordMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_port2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class MasterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.MasterRequest) */ {
 public:
  inline MasterRequest() : MasterRequest(nullptr) {}
  ~MasterRequest() override;
  explicit constexpr MasterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterRequest(const MasterRequest& from);
  MasterRequest(MasterRequest&& from) noexcept
    : MasterRequest() {
    *this = ::std::move(from);
  }

  inline MasterRequest& operator=(const MasterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterRequest& operator=(MasterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterRequest* internal_default_instance() {
    return reinterpret_cast<const MasterRequest*>(
               &_MasterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MasterRequest& a, MasterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterRequest* New() const final {
    return new MasterRequest();
  }

  MasterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.MasterRequest";
  }
  protected:
  explicit MasterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 1,
  };
  // string server_id = 1;
  void clear_server_id();
  const std::string& server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_id();
  void set_allocated_server_id(std::string* server_id);
  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
  std::string* _internal_mutable_server_id();
  public:

  // @@protoc_insertion_point(class_scope:csce438.MasterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class MasterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.MasterReply) */ {
 public:
  inline MasterReply() : MasterReply(nullptr) {}
  ~MasterReply() override;
  explicit constexpr MasterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterReply(const MasterReply& from);
  MasterReply(MasterReply&& from) noexcept
    : MasterReply() {
    *this = ::std::move(from);
  }

  inline MasterReply& operator=(const MasterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterReply& operator=(MasterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterReply* internal_default_instance() {
    return reinterpret_cast<const MasterReply*>(
               &_MasterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MasterReply& a, MasterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterReply* New() const final {
    return new MasterReply();
  }

  MasterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.MasterReply";
  }
  protected:
  explicit MasterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlaveIpFieldNumber = 1,
    kSlavePortFieldNumber = 2,
  };
  // string slave_ip = 1;
  void clear_slave_ip();
  const std::string& slave_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slave_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slave_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_slave_ip();
  void set_allocated_slave_ip(std::string* slave_ip);
  private:
  const std::string& _internal_slave_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slave_ip(const std::string& value);
  std::string* _internal_mutable_slave_ip();
  public:

  // string slave_port = 2;
  void clear_slave_port();
  const std::string& slave_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slave_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slave_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_slave_port();
  void set_allocated_slave_port(std::string* slave_port);
  private:
  const std::string& _internal_slave_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slave_port(const std::string& value);
  std::string* _internal_mutable_slave_port();
  public:

  // @@protoc_insertion_point(class_scope:csce438.MasterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slave_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slave_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class FollowerSyncRTInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.FollowerSyncRTInfo) */ {
 public:
  inline FollowerSyncRTInfo() : FollowerSyncRTInfo(nullptr) {}
  ~FollowerSyncRTInfo() override;
  explicit constexpr FollowerSyncRTInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowerSyncRTInfo(const FollowerSyncRTInfo& from);
  FollowerSyncRTInfo(FollowerSyncRTInfo&& from) noexcept
    : FollowerSyncRTInfo() {
    *this = ::std::move(from);
  }

  inline FollowerSyncRTInfo& operator=(const FollowerSyncRTInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowerSyncRTInfo& operator=(FollowerSyncRTInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowerSyncRTInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowerSyncRTInfo* internal_default_instance() {
    return reinterpret_cast<const FollowerSyncRTInfo*>(
               &_FollowerSyncRTInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FollowerSyncRTInfo& a, FollowerSyncRTInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowerSyncRTInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowerSyncRTInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowerSyncRTInfo* New() const final {
    return new FollowerSyncRTInfo();
  }

  FollowerSyncRTInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowerSyncRTInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowerSyncRTInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FollowerSyncRTInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowerSyncRTInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.FollowerSyncRTInfo";
  }
  protected:
  explicit FollowerSyncRTInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyncIpAddressFieldNumber = 1,
    kSyncPortFieldNumber = 2,
    kSyncIdFieldNumber = 3,
  };
  // string sync_ip_address = 1;
  void clear_sync_ip_address();
  const std::string& sync_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_ip_address();
  void set_allocated_sync_ip_address(std::string* sync_ip_address);
  private:
  const std::string& _internal_sync_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_ip_address(const std::string& value);
  std::string* _internal_mutable_sync_ip_address();
  public:

  // string sync_port = 2;
  void clear_sync_port();
  const std::string& sync_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_port();
  void set_allocated_sync_port(std::string* sync_port);
  private:
  const std::string& _internal_sync_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_port(const std::string& value);
  std::string* _internal_mutable_sync_port();
  public:

  // string sync_id = 3;
  void clear_sync_id();
  const std::string& sync_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_id();
  void set_allocated_sync_id(std::string* sync_id);
  private:
  const std::string& _internal_sync_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_id(const std::string& value);
  std::string* _internal_mutable_sync_id();
  public:

  // @@protoc_insertion_point(class_scope:csce438.FollowerSyncRTInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit constexpr ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientInfo* New() const final {
    return new ClientInfo();
  }

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientId2FieldNumber = 1,
  };
  // string client_id2 = 1;
  void clear_client_id2();
  const std::string& client_id2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id2();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_id2();
  void set_allocated_client_id2(std::string* client_id2);
  private:
  const std::string& _internal_client_id2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id2(const std::string& value);
  std::string* _internal_mutable_client_id2();
  public:

  // @@protoc_insertion_point(class_scope:csce438.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class FollowerSyncInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.FollowerSyncInfo) */ {
 public:
  inline FollowerSyncInfo() : FollowerSyncInfo(nullptr) {}
  ~FollowerSyncInfo() override;
  explicit constexpr FollowerSyncInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowerSyncInfo(const FollowerSyncInfo& from);
  FollowerSyncInfo(FollowerSyncInfo&& from) noexcept
    : FollowerSyncInfo() {
    *this = ::std::move(from);
  }

  inline FollowerSyncInfo& operator=(const FollowerSyncInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowerSyncInfo& operator=(FollowerSyncInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowerSyncInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowerSyncInfo* internal_default_instance() {
    return reinterpret_cast<const FollowerSyncInfo*>(
               &_FollowerSyncInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FollowerSyncInfo& a, FollowerSyncInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowerSyncInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowerSyncInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowerSyncInfo* New() const final {
    return new FollowerSyncInfo();
  }

  FollowerSyncInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowerSyncInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowerSyncInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FollowerSyncInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowerSyncInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.FollowerSyncInfo";
  }
  protected:
  explicit FollowerSyncInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyncIpAddressFieldNumber = 1,
    kSyncPortFieldNumber = 2,
    kSyncId2FieldNumber = 3,
  };
  // string sync_ip_address = 1;
  void clear_sync_ip_address();
  const std::string& sync_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_ip_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_ip_address();
  void set_allocated_sync_ip_address(std::string* sync_ip_address);
  private:
  const std::string& _internal_sync_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_ip_address(const std::string& value);
  std::string* _internal_mutable_sync_ip_address();
  public:

  // string sync_port = 2;
  void clear_sync_port();
  const std::string& sync_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_port();
  void set_allocated_sync_port(std::string* sync_port);
  private:
  const std::string& _internal_sync_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_port(const std::string& value);
  std::string* _internal_mutable_sync_port();
  public:

  // string sync_id2 = 3;
  void clear_sync_id2();
  const std::string& sync_id2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_id2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_id2();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_id2();
  void set_allocated_sync_id2(std::string* sync_id2);
  private:
  const std::string& _internal_sync_id2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_id2(const std::string& value);
  std::string* _internal_mutable_sync_id2();
  public:

  // @@protoc_insertion_point(class_scope:csce438.FollowerSyncInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_id2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class SyncIdInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.SyncIdInfo) */ {
 public:
  inline SyncIdInfo() : SyncIdInfo(nullptr) {}
  ~SyncIdInfo() override;
  explicit constexpr SyncIdInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncIdInfo(const SyncIdInfo& from);
  SyncIdInfo(SyncIdInfo&& from) noexcept
    : SyncIdInfo() {
    *this = ::std::move(from);
  }

  inline SyncIdInfo& operator=(const SyncIdInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncIdInfo& operator=(SyncIdInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncIdInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncIdInfo* internal_default_instance() {
    return reinterpret_cast<const SyncIdInfo*>(
               &_SyncIdInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SyncIdInfo& a, SyncIdInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncIdInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncIdInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SyncIdInfo* New() const final {
    return new SyncIdInfo();
  }

  SyncIdInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SyncIdInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncIdInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SyncIdInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncIdInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.SyncIdInfo";
  }
  protected:
  explicit SyncIdInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyncIdFieldNumber = 1,
  };
  // string sync_id = 1;
  void clear_sync_id();
  const std::string& sync_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_sync_id();
  void set_allocated_sync_id(std::string* sync_id);
  private:
  const std::string& _internal_sync_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_id(const std::string& value);
  std::string* _internal_mutable_sync_id();
  public:

  // @@protoc_insertion_point(class_scope:csce438.SyncIdInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// -------------------------------------------------------------------

class ClusterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ClusterInfo) */ {
 public:
  inline ClusterInfo() : ClusterInfo(nullptr) {}
  ~ClusterInfo() override;
  explicit constexpr ClusterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClusterInfo(const ClusterInfo& from);
  ClusterInfo(ClusterInfo&& from) noexcept
    : ClusterInfo() {
    *this = ::std::move(from);
  }

  inline ClusterInfo& operator=(const ClusterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusterInfo& operator=(ClusterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClusterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClusterInfo* internal_default_instance() {
    return reinterpret_cast<const ClusterInfo*>(
               &_ClusterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClusterInfo& a, ClusterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusterInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClusterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClusterInfo* New() const final {
    return new ClusterInfo();
  }

  ClusterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClusterInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClusterInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClusterInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csce438.ClusterInfo";
  }
  protected:
  explicit ClusterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterClientsFieldNumber = 1,
  };
  // repeated string cluster_clients = 1;
  int cluster_clients_size() const;
  private:
  int _internal_cluster_clients_size() const;
  public:
  void clear_cluster_clients();
  const std::string& cluster_clients(int index) const;
  std::string* mutable_cluster_clients(int index);
  void set_cluster_clients(int index, const std::string& value);
  void set_cluster_clients(int index, std::string&& value);
  void set_cluster_clients(int index, const char* value);
  void set_cluster_clients(int index, const char* value, size_t size);
  std::string* add_cluster_clients();
  void add_cluster_clients(const std::string& value);
  void add_cluster_clients(std::string&& value);
  void add_cluster_clients(const char* value);
  void add_cluster_clients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cluster_clients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cluster_clients();
  private:
  const std::string& _internal_cluster_clients(int index) const;
  std::string* _internal_add_cluster_clients();
  public:

  // @@protoc_insertion_point(class_scope:csce438.ClusterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cluster_clients_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_coord_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CoordRequest

// string client_id = 1;
inline void CoordRequest::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& CoordRequest::client_id() const {
  // @@protoc_insertion_point(field_get:csce438.CoordRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordRequest.client_id)
}
inline std::string* CoordRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:csce438.CoordRequest.client_id)
  return _s;
}
inline const std::string& CoordRequest::_internal_client_id() const {
  return client_id_.Get();
}
inline void CoordRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordRequest::_internal_mutable_client_id() {
  
  return client_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:csce438.CoordRequest.client_id)
  return client_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordRequest.client_id)
}

// -------------------------------------------------------------------

// CoordReply

// string server_ip_address = 1;
inline void CoordReply::clear_server_ip_address() {
  server_ip_address_.ClearToEmpty();
}
inline const std::string& CoordReply::server_ip_address() const {
  // @@protoc_insertion_point(field_get:csce438.CoordReply.server_ip_address)
  return _internal_server_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordReply::set_server_ip_address(ArgT0&& arg0, ArgT... args) {
 
 server_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordReply.server_ip_address)
}
inline std::string* CoordReply::mutable_server_ip_address() {
  std::string* _s = _internal_mutable_server_ip_address();
  // @@protoc_insertion_point(field_mutable:csce438.CoordReply.server_ip_address)
  return _s;
}
inline const std::string& CoordReply::_internal_server_ip_address() const {
  return server_ip_address_.Get();
}
inline void CoordReply::_internal_set_server_ip_address(const std::string& value) {
  
  server_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordReply::_internal_mutable_server_ip_address() {
  
  return server_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordReply::release_server_ip_address() {
  // @@protoc_insertion_point(field_release:csce438.CoordReply.server_ip_address)
  return server_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordReply::set_allocated_server_ip_address(std::string* server_ip_address) {
  if (server_ip_address != nullptr) {
    
  } else {
    
  }
  server_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordReply.server_ip_address)
}

// string server_port = 2;
inline void CoordReply::clear_server_port() {
  server_port_.ClearToEmpty();
}
inline const std::string& CoordReply::server_port() const {
  // @@protoc_insertion_point(field_get:csce438.CoordReply.server_port)
  return _internal_server_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordReply::set_server_port(ArgT0&& arg0, ArgT... args) {
 
 server_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordReply.server_port)
}
inline std::string* CoordReply::mutable_server_port() {
  std::string* _s = _internal_mutable_server_port();
  // @@protoc_insertion_point(field_mutable:csce438.CoordReply.server_port)
  return _s;
}
inline const std::string& CoordReply::_internal_server_port() const {
  return server_port_.Get();
}
inline void CoordReply::_internal_set_server_port(const std::string& value) {
  
  server_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordReply::_internal_mutable_server_port() {
  
  return server_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordReply::release_server_port() {
  // @@protoc_insertion_point(field_release:csce438.CoordReply.server_port)
  return server_port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordReply::set_allocated_server_port(std::string* server_port) {
  if (server_port != nullptr) {
    
  } else {
    
  }
  server_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordReply.server_port)
}

// -------------------------------------------------------------------

// CoordMessage

// string server_ip = 1;
inline void CoordMessage::clear_server_ip() {
  server_ip_.ClearToEmpty();
}
inline const std::string& CoordMessage::server_ip() const {
  // @@protoc_insertion_point(field_get:csce438.CoordMessage.server_ip)
  return _internal_server_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordMessage::set_server_ip(ArgT0&& arg0, ArgT... args) {
 
 server_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordMessage.server_ip)
}
inline std::string* CoordMessage::mutable_server_ip() {
  std::string* _s = _internal_mutable_server_ip();
  // @@protoc_insertion_point(field_mutable:csce438.CoordMessage.server_ip)
  return _s;
}
inline const std::string& CoordMessage::_internal_server_ip() const {
  return server_ip_.Get();
}
inline void CoordMessage::_internal_set_server_ip(const std::string& value) {
  
  server_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordMessage::_internal_mutable_server_ip() {
  
  return server_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordMessage::release_server_ip() {
  // @@protoc_insertion_point(field_release:csce438.CoordMessage.server_ip)
  return server_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordMessage::set_allocated_server_ip(std::string* server_ip) {
  if (server_ip != nullptr) {
    
  } else {
    
  }
  server_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordMessage.server_ip)
}

// string server_port2 = 2;
inline void CoordMessage::clear_server_port2() {
  server_port2_.ClearToEmpty();
}
inline const std::string& CoordMessage::server_port2() const {
  // @@protoc_insertion_point(field_get:csce438.CoordMessage.server_port2)
  return _internal_server_port2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordMessage::set_server_port2(ArgT0&& arg0, ArgT... args) {
 
 server_port2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordMessage.server_port2)
}
inline std::string* CoordMessage::mutable_server_port2() {
  std::string* _s = _internal_mutable_server_port2();
  // @@protoc_insertion_point(field_mutable:csce438.CoordMessage.server_port2)
  return _s;
}
inline const std::string& CoordMessage::_internal_server_port2() const {
  return server_port2_.Get();
}
inline void CoordMessage::_internal_set_server_port2(const std::string& value) {
  
  server_port2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordMessage::_internal_mutable_server_port2() {
  
  return server_port2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordMessage::release_server_port2() {
  // @@protoc_insertion_point(field_release:csce438.CoordMessage.server_port2)
  return server_port2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordMessage::set_allocated_server_port2(std::string* server_port2) {
  if (server_port2 != nullptr) {
    
  } else {
    
  }
  server_port2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_port2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordMessage.server_port2)
}

// string status = 3;
inline void CoordMessage::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& CoordMessage::status() const {
  // @@protoc_insertion_point(field_get:csce438.CoordMessage.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordMessage::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordMessage.status)
}
inline std::string* CoordMessage::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:csce438.CoordMessage.status)
  return _s;
}
inline const std::string& CoordMessage::_internal_status() const {
  return status_.Get();
}
inline void CoordMessage::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordMessage::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordMessage::release_status() {
  // @@protoc_insertion_point(field_release:csce438.CoordMessage.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordMessage::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordMessage.status)
}

// string server_type = 4;
inline void CoordMessage::clear_server_type() {
  server_type_.ClearToEmpty();
}
inline const std::string& CoordMessage::server_type() const {
  // @@protoc_insertion_point(field_get:csce438.CoordMessage.server_type)
  return _internal_server_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoordMessage::set_server_type(ArgT0&& arg0, ArgT... args) {
 
 server_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.CoordMessage.server_type)
}
inline std::string* CoordMessage::mutable_server_type() {
  std::string* _s = _internal_mutable_server_type();
  // @@protoc_insertion_point(field_mutable:csce438.CoordMessage.server_type)
  return _s;
}
inline const std::string& CoordMessage::_internal_server_type() const {
  return server_type_.Get();
}
inline void CoordMessage::_internal_set_server_type(const std::string& value) {
  
  server_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CoordMessage::_internal_mutable_server_type() {
  
  return server_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CoordMessage::release_server_type() {
  // @@protoc_insertion_point(field_release:csce438.CoordMessage.server_type)
  return server_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CoordMessage::set_allocated_server_type(std::string* server_type) {
  if (server_type != nullptr) {
    
  } else {
    
  }
  server_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.CoordMessage.server_type)
}

// -------------------------------------------------------------------

// MasterRequest

// string server_id = 1;
inline void MasterRequest::clear_server_id() {
  server_id_.ClearToEmpty();
}
inline const std::string& MasterRequest::server_id() const {
  // @@protoc_insertion_point(field_get:csce438.MasterRequest.server_id)
  return _internal_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterRequest::set_server_id(ArgT0&& arg0, ArgT... args) {
 
 server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.MasterRequest.server_id)
}
inline std::string* MasterRequest::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:csce438.MasterRequest.server_id)
  return _s;
}
inline const std::string& MasterRequest::_internal_server_id() const {
  return server_id_.Get();
}
inline void MasterRequest::_internal_set_server_id(const std::string& value) {
  
  server_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MasterRequest::_internal_mutable_server_id() {
  
  return server_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MasterRequest::release_server_id() {
  // @@protoc_insertion_point(field_release:csce438.MasterRequest.server_id)
  return server_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MasterRequest::set_allocated_server_id(std::string* server_id) {
  if (server_id != nullptr) {
    
  } else {
    
  }
  server_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.MasterRequest.server_id)
}

// -------------------------------------------------------------------

// MasterReply

// string slave_ip = 1;
inline void MasterReply::clear_slave_ip() {
  slave_ip_.ClearToEmpty();
}
inline const std::string& MasterReply::slave_ip() const {
  // @@protoc_insertion_point(field_get:csce438.MasterReply.slave_ip)
  return _internal_slave_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterReply::set_slave_ip(ArgT0&& arg0, ArgT... args) {
 
 slave_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.MasterReply.slave_ip)
}
inline std::string* MasterReply::mutable_slave_ip() {
  std::string* _s = _internal_mutable_slave_ip();
  // @@protoc_insertion_point(field_mutable:csce438.MasterReply.slave_ip)
  return _s;
}
inline const std::string& MasterReply::_internal_slave_ip() const {
  return slave_ip_.Get();
}
inline void MasterReply::_internal_set_slave_ip(const std::string& value) {
  
  slave_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MasterReply::_internal_mutable_slave_ip() {
  
  return slave_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MasterReply::release_slave_ip() {
  // @@protoc_insertion_point(field_release:csce438.MasterReply.slave_ip)
  return slave_ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MasterReply::set_allocated_slave_ip(std::string* slave_ip) {
  if (slave_ip != nullptr) {
    
  } else {
    
  }
  slave_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slave_ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.MasterReply.slave_ip)
}

// string slave_port = 2;
inline void MasterReply::clear_slave_port() {
  slave_port_.ClearToEmpty();
}
inline const std::string& MasterReply::slave_port() const {
  // @@protoc_insertion_point(field_get:csce438.MasterReply.slave_port)
  return _internal_slave_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterReply::set_slave_port(ArgT0&& arg0, ArgT... args) {
 
 slave_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.MasterReply.slave_port)
}
inline std::string* MasterReply::mutable_slave_port() {
  std::string* _s = _internal_mutable_slave_port();
  // @@protoc_insertion_point(field_mutable:csce438.MasterReply.slave_port)
  return _s;
}
inline const std::string& MasterReply::_internal_slave_port() const {
  return slave_port_.Get();
}
inline void MasterReply::_internal_set_slave_port(const std::string& value) {
  
  slave_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MasterReply::_internal_mutable_slave_port() {
  
  return slave_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MasterReply::release_slave_port() {
  // @@protoc_insertion_point(field_release:csce438.MasterReply.slave_port)
  return slave_port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MasterReply::set_allocated_slave_port(std::string* slave_port) {
  if (slave_port != nullptr) {
    
  } else {
    
  }
  slave_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slave_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.MasterReply.slave_port)
}

// -------------------------------------------------------------------

// FollowerSyncRTInfo

// string sync_ip_address = 1;
inline void FollowerSyncRTInfo::clear_sync_ip_address() {
  sync_ip_address_.ClearToEmpty();
}
inline const std::string& FollowerSyncRTInfo::sync_ip_address() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncRTInfo.sync_ip_address)
  return _internal_sync_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncRTInfo::set_sync_ip_address(ArgT0&& arg0, ArgT... args) {
 
 sync_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncRTInfo.sync_ip_address)
}
inline std::string* FollowerSyncRTInfo::mutable_sync_ip_address() {
  std::string* _s = _internal_mutable_sync_ip_address();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncRTInfo.sync_ip_address)
  return _s;
}
inline const std::string& FollowerSyncRTInfo::_internal_sync_ip_address() const {
  return sync_ip_address_.Get();
}
inline void FollowerSyncRTInfo::_internal_set_sync_ip_address(const std::string& value) {
  
  sync_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::_internal_mutable_sync_ip_address() {
  
  return sync_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::release_sync_ip_address() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncRTInfo.sync_ip_address)
  return sync_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncRTInfo::set_allocated_sync_ip_address(std::string* sync_ip_address) {
  if (sync_ip_address != nullptr) {
    
  } else {
    
  }
  sync_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncRTInfo.sync_ip_address)
}

// string sync_port = 2;
inline void FollowerSyncRTInfo::clear_sync_port() {
  sync_port_.ClearToEmpty();
}
inline const std::string& FollowerSyncRTInfo::sync_port() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncRTInfo.sync_port)
  return _internal_sync_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncRTInfo::set_sync_port(ArgT0&& arg0, ArgT... args) {
 
 sync_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncRTInfo.sync_port)
}
inline std::string* FollowerSyncRTInfo::mutable_sync_port() {
  std::string* _s = _internal_mutable_sync_port();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncRTInfo.sync_port)
  return _s;
}
inline const std::string& FollowerSyncRTInfo::_internal_sync_port() const {
  return sync_port_.Get();
}
inline void FollowerSyncRTInfo::_internal_set_sync_port(const std::string& value) {
  
  sync_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::_internal_mutable_sync_port() {
  
  return sync_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::release_sync_port() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncRTInfo.sync_port)
  return sync_port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncRTInfo::set_allocated_sync_port(std::string* sync_port) {
  if (sync_port != nullptr) {
    
  } else {
    
  }
  sync_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncRTInfo.sync_port)
}

// string sync_id = 3;
inline void FollowerSyncRTInfo::clear_sync_id() {
  sync_id_.ClearToEmpty();
}
inline const std::string& FollowerSyncRTInfo::sync_id() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncRTInfo.sync_id)
  return _internal_sync_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncRTInfo::set_sync_id(ArgT0&& arg0, ArgT... args) {
 
 sync_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncRTInfo.sync_id)
}
inline std::string* FollowerSyncRTInfo::mutable_sync_id() {
  std::string* _s = _internal_mutable_sync_id();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncRTInfo.sync_id)
  return _s;
}
inline const std::string& FollowerSyncRTInfo::_internal_sync_id() const {
  return sync_id_.Get();
}
inline void FollowerSyncRTInfo::_internal_set_sync_id(const std::string& value) {
  
  sync_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::_internal_mutable_sync_id() {
  
  return sync_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncRTInfo::release_sync_id() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncRTInfo.sync_id)
  return sync_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncRTInfo::set_allocated_sync_id(std::string* sync_id) {
  if (sync_id != nullptr) {
    
  } else {
    
  }
  sync_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncRTInfo.sync_id)
}

// -------------------------------------------------------------------

// ClientInfo

// string client_id2 = 1;
inline void ClientInfo::clear_client_id2() {
  client_id2_.ClearToEmpty();
}
inline const std::string& ClientInfo::client_id2() const {
  // @@protoc_insertion_point(field_get:csce438.ClientInfo.client_id2)
  return _internal_client_id2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_client_id2(ArgT0&& arg0, ArgT... args) {
 
 client_id2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.ClientInfo.client_id2)
}
inline std::string* ClientInfo::mutable_client_id2() {
  std::string* _s = _internal_mutable_client_id2();
  // @@protoc_insertion_point(field_mutable:csce438.ClientInfo.client_id2)
  return _s;
}
inline const std::string& ClientInfo::_internal_client_id2() const {
  return client_id2_.Get();
}
inline void ClientInfo::_internal_set_client_id2(const std::string& value) {
  
  client_id2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_client_id2() {
  
  return client_id2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientInfo::release_client_id2() {
  // @@protoc_insertion_point(field_release:csce438.ClientInfo.client_id2)
  return client_id2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientInfo::set_allocated_client_id2(std::string* client_id2) {
  if (client_id2 != nullptr) {
    
  } else {
    
  }
  client_id2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.ClientInfo.client_id2)
}

// -------------------------------------------------------------------

// FollowerSyncInfo

// string sync_ip_address = 1;
inline void FollowerSyncInfo::clear_sync_ip_address() {
  sync_ip_address_.ClearToEmpty();
}
inline const std::string& FollowerSyncInfo::sync_ip_address() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncInfo.sync_ip_address)
  return _internal_sync_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncInfo::set_sync_ip_address(ArgT0&& arg0, ArgT... args) {
 
 sync_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncInfo.sync_ip_address)
}
inline std::string* FollowerSyncInfo::mutable_sync_ip_address() {
  std::string* _s = _internal_mutable_sync_ip_address();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncInfo.sync_ip_address)
  return _s;
}
inline const std::string& FollowerSyncInfo::_internal_sync_ip_address() const {
  return sync_ip_address_.Get();
}
inline void FollowerSyncInfo::_internal_set_sync_ip_address(const std::string& value) {
  
  sync_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::_internal_mutable_sync_ip_address() {
  
  return sync_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::release_sync_ip_address() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncInfo.sync_ip_address)
  return sync_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncInfo::set_allocated_sync_ip_address(std::string* sync_ip_address) {
  if (sync_ip_address != nullptr) {
    
  } else {
    
  }
  sync_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_ip_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncInfo.sync_ip_address)
}

// string sync_port = 2;
inline void FollowerSyncInfo::clear_sync_port() {
  sync_port_.ClearToEmpty();
}
inline const std::string& FollowerSyncInfo::sync_port() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncInfo.sync_port)
  return _internal_sync_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncInfo::set_sync_port(ArgT0&& arg0, ArgT... args) {
 
 sync_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncInfo.sync_port)
}
inline std::string* FollowerSyncInfo::mutable_sync_port() {
  std::string* _s = _internal_mutable_sync_port();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncInfo.sync_port)
  return _s;
}
inline const std::string& FollowerSyncInfo::_internal_sync_port() const {
  return sync_port_.Get();
}
inline void FollowerSyncInfo::_internal_set_sync_port(const std::string& value) {
  
  sync_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::_internal_mutable_sync_port() {
  
  return sync_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::release_sync_port() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncInfo.sync_port)
  return sync_port_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncInfo::set_allocated_sync_port(std::string* sync_port) {
  if (sync_port != nullptr) {
    
  } else {
    
  }
  sync_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncInfo.sync_port)
}

// string sync_id2 = 3;
inline void FollowerSyncInfo::clear_sync_id2() {
  sync_id2_.ClearToEmpty();
}
inline const std::string& FollowerSyncInfo::sync_id2() const {
  // @@protoc_insertion_point(field_get:csce438.FollowerSyncInfo.sync_id2)
  return _internal_sync_id2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FollowerSyncInfo::set_sync_id2(ArgT0&& arg0, ArgT... args) {
 
 sync_id2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.FollowerSyncInfo.sync_id2)
}
inline std::string* FollowerSyncInfo::mutable_sync_id2() {
  std::string* _s = _internal_mutable_sync_id2();
  // @@protoc_insertion_point(field_mutable:csce438.FollowerSyncInfo.sync_id2)
  return _s;
}
inline const std::string& FollowerSyncInfo::_internal_sync_id2() const {
  return sync_id2_.Get();
}
inline void FollowerSyncInfo::_internal_set_sync_id2(const std::string& value) {
  
  sync_id2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::_internal_mutable_sync_id2() {
  
  return sync_id2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FollowerSyncInfo::release_sync_id2() {
  // @@protoc_insertion_point(field_release:csce438.FollowerSyncInfo.sync_id2)
  return sync_id2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FollowerSyncInfo::set_allocated_sync_id2(std::string* sync_id2) {
  if (sync_id2 != nullptr) {
    
  } else {
    
  }
  sync_id2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_id2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.FollowerSyncInfo.sync_id2)
}

// -------------------------------------------------------------------

// SyncIdInfo

// string sync_id = 1;
inline void SyncIdInfo::clear_sync_id() {
  sync_id_.ClearToEmpty();
}
inline const std::string& SyncIdInfo::sync_id() const {
  // @@protoc_insertion_point(field_get:csce438.SyncIdInfo.sync_id)
  return _internal_sync_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncIdInfo::set_sync_id(ArgT0&& arg0, ArgT... args) {
 
 sync_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.SyncIdInfo.sync_id)
}
inline std::string* SyncIdInfo::mutable_sync_id() {
  std::string* _s = _internal_mutable_sync_id();
  // @@protoc_insertion_point(field_mutable:csce438.SyncIdInfo.sync_id)
  return _s;
}
inline const std::string& SyncIdInfo::_internal_sync_id() const {
  return sync_id_.Get();
}
inline void SyncIdInfo::_internal_set_sync_id(const std::string& value) {
  
  sync_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SyncIdInfo::_internal_mutable_sync_id() {
  
  return sync_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SyncIdInfo::release_sync_id() {
  // @@protoc_insertion_point(field_release:csce438.SyncIdInfo.sync_id)
  return sync_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SyncIdInfo::set_allocated_sync_id(std::string* sync_id) {
  if (sync_id != nullptr) {
    
  } else {
    
  }
  sync_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sync_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:csce438.SyncIdInfo.sync_id)
}

// -------------------------------------------------------------------

// ClusterInfo

// repeated string cluster_clients = 1;
inline int ClusterInfo::_internal_cluster_clients_size() const {
  return cluster_clients_.size();
}
inline int ClusterInfo::cluster_clients_size() const {
  return _internal_cluster_clients_size();
}
inline void ClusterInfo::clear_cluster_clients() {
  cluster_clients_.Clear();
}
inline std::string* ClusterInfo::add_cluster_clients() {
  std::string* _s = _internal_add_cluster_clients();
  // @@protoc_insertion_point(field_add_mutable:csce438.ClusterInfo.cluster_clients)
  return _s;
}
inline const std::string& ClusterInfo::_internal_cluster_clients(int index) const {
  return cluster_clients_.Get(index);
}
inline const std::string& ClusterInfo::cluster_clients(int index) const {
  // @@protoc_insertion_point(field_get:csce438.ClusterInfo.cluster_clients)
  return _internal_cluster_clients(index);
}
inline std::string* ClusterInfo::mutable_cluster_clients(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.ClusterInfo.cluster_clients)
  return cluster_clients_.Mutable(index);
}
inline void ClusterInfo::set_cluster_clients(int index, const std::string& value) {
  cluster_clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::set_cluster_clients(int index, std::string&& value) {
  cluster_clients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::set_cluster_clients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cluster_clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::set_cluster_clients(int index, const char* value, size_t size) {
  cluster_clients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.ClusterInfo.cluster_clients)
}
inline std::string* ClusterInfo::_internal_add_cluster_clients() {
  return cluster_clients_.Add();
}
inline void ClusterInfo::add_cluster_clients(const std::string& value) {
  cluster_clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::add_cluster_clients(std::string&& value) {
  cluster_clients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::add_cluster_clients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cluster_clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.ClusterInfo.cluster_clients)
}
inline void ClusterInfo::add_cluster_clients(const char* value, size_t size) {
  cluster_clients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.ClusterInfo.cluster_clients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClusterInfo::cluster_clients() const {
  // @@protoc_insertion_point(field_list:csce438.ClusterInfo.cluster_clients)
  return cluster_clients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClusterInfo::mutable_cluster_clients() {
  // @@protoc_insertion_point(field_mutable_list:csce438.ClusterInfo.cluster_clients)
  return &cluster_clients_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace csce438

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_coord_2eproto
